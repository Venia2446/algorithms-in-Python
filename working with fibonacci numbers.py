k, f = (int(i) for i in input().split())
while k not in range(1, (10 ** 18) + 1):
    print('введите k от 1 до 10**18')
    k = int(input())
while f not in range(2, (10 ** 5) + 1):
    print('введите f от 2 до 10**5')
    f = int(input())
if k == 1:
    print(0)
else:
    s = [1, 1]  # n = 1, f(n) =0 Долго мучился с Test 7.

    for i in range(2, f ** 2 + 1):
        s += [(s[i - 2] + s[i - 1]) % f]
        if s[i - 2] == 0 and s[i - 1] == 1:
            break

    h = [0] + s

    l = len(h) - 3

    q = k % l

    print(h[q])

#Насчёт 6m. Есть прекрасный тест (не из проверочных здесь), где n=93, m=10, который добивает до 6*m - 1. Поэтому цикл надо ставить  до 6*m+1, поскольку ещё проверочные 0 и 1 должны влезть. Для Питона соответственно 6*m+2, так как он не берёт правый край

'''Собираем в список остатки по модулю m до тех пор, пока не получим период. Он всегда начинается с 0,1

Искомый остаток будет n по модулю длины этого списка. Без особых замудрений, что в форуме ниже ;)

Например, n = 10, m = 4. Список остаков будет такой 0,1,1,2,3,1 так как дальше все время будет повторяться.

Теперь 10 по модулю 6(длина списка) = 4. А четвертый элемент списка это 3. Проверяем, 55 mod 4 = 3. Ок?'''

#Кто застрял на 5 тесте по методу Пизано, из вики: Последовательность Фибоначчи по модулю любого целого положительного числа m периодична, так как среди первых m^2+1 чисел найдутся две равные пары...... Т.е., поиск периода надо производить в диапазоне до m^2+1, а не до n, как я ))
#  читайте Вики до конца ))), последнее свойство говорит, что период для m <= 6 * m